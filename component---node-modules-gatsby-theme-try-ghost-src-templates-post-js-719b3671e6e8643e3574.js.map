{"version":3,"sources":["webpack:///./node_modules/gatsby-theme-try-ghost/src/templates/post.js"],"names":["Post","data","location","pageContext","basePath","useOptions","text","get","useLang","post","ghostPost","prevPost","prev","nextPost","next","previewPosts","allGhostPost","edges","readingTime","readingTimeHelper","replace","featImg","feature_image","fluidFeatureImg","featureImageSharp","childImageSharp","fluid","postClass","PostClass","tags","isFeatured","isImage","primaryTagCount","transformedHtml","childHtmlRehype","html","toc","tableOfContents","forEach","node","collectionPath","collectionPaths","id","Fragment","type","codeinjection_styles","throttle","isPost","activeClass","render","sticky","overlay","header","title","posts","className","primary_tag","to","resolveUrl","slug","url","name","ref","anchorRef","custom_excerpt","authors","map","author","i","key","dateTime","published_at","published_at_pretty","fluidClass","fluidImg","srcImg","dangerouslySetInnerHTML","__html","postQuery"],"mappings":"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","file":"component---node-modules-gatsby-theme-try-ghost-src-templates-post-js-719b3671e6e8643e3574.js","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Link, graphql } from 'gatsby'\nimport { Helmet } from 'react-helmet'\n\nimport { readingTime as readingTimeHelper } from '@tryghost/helpers'\nimport { resolveUrl } from '../utils/routing'\nimport useOptions from '../utils/use-options'\nimport { useLang, get } from '../utils/use-lang'\n\nimport { Layout, HeaderPost, AuthorList, PreviewPosts, ImgSharp } from '../components/common'\nimport { Comments, TableOfContents, Subscribe } from '../components/common'\n\nimport { StickyNavContainer, OverlayContainer } from '../components/common/effects'\nimport { MetaData } from '../components/common/meta'\n\nimport { PostClass } from '../components/common/helpers'\n\n/**\n* Single post view (/:slug)\n*\n* This file renders a single post and loads all the content.\n*\n*/\nconst Post = ({ data, location, pageContext }) => {\n    const { basePath } = useOptions()\n    const text = get(useLang())\n    const post = data.ghostPost\n    const prevPost = data.prev\n    const nextPost = data.next\n    const previewPosts = data.allGhostPost.edges\n    const readingTime = readingTimeHelper(post).replace(`min read`,text(`MIN_READ`))\n    const featImg = post.feature_image\n    const fluidFeatureImg = post.featureImageSharp && post.featureImageSharp.childImageSharp && post.featureImageSharp.childImageSharp.fluid\n    const postClass = PostClass({ tags: post.tags, isFeatured: featImg, isImage: featImg && true })\n\n    const primaryTagCount = pageContext.primaryTagCount\n    const transformedHtml = post.childHtmlRehype && post.childHtmlRehype.html\n    const toc = post.childHtmlRehype && post.childHtmlRehype.tableOfContents || []\n\n    // Collection paths must be retreived from pageContext\n    previewPosts.forEach(({ node }) => node.collectionPath = pageContext.collectionPaths[node.id])\n    if (prevPost) {\n        prevPost.collectionPath = pageContext.collectionPaths[prevPost.id]\n    }\n    if (nextPost) {\n        nextPost.collectionPath = pageContext.collectionPaths[nextPost.id]\n    }\n\n    return (\n        <React.Fragment>\n            <MetaData data={data} location={location} type=\"article\"/>\n            <Helmet>\n                <style type=\"text/css\">{`${post.codeinjection_styles}`}</style>\n            </Helmet>\n            <StickyNavContainer throttle={300} isPost={true} activeClass=\"nav-post-title-active\" render={ sticky => (\n                <OverlayContainer render={ overlay => (\n                    <Layout isPost={true} sticky={sticky} overlay={overlay}\n                        header={<HeaderPost sticky={sticky} title={post.title} overlay={overlay}/>}\n                        previewPosts={<PreviewPosts posts={previewPosts} primaryTagCount={primaryTagCount} prev={prevPost} next={nextPost}/>}>\n                        <div className=\"inner\">\n                            <article className={`post-full ${postClass}`}>\n                                <header className=\"post-full-header\">\n                                    { post.primary_tag &&\n                                            <section className=\"post-full-tags\">\n                                                <Link to={resolveUrl(basePath, `/`, post.primary_tag.slug, post.primary_tag.url)}>{post.primary_tag.name}</Link>\n                                            </section>\n                                    }\n\n                                    <h1 ref={sticky && sticky.anchorRef} className=\"post-full-title\">{post.title}</h1>\n\n                                    { post.custom_excerpt &&\n                                        <p className=\"post-full-custom-excerpt\">{post.custom_excerpt}</p>\n                                    }\n\n                                    <div className=\"post-full-byline\">\n                                        <section className=\"post-full-byline-content\">\n                                            <AuthorList authors={post.authors} isPost={true}/>\n\n                                            <section className=\"post-full-byline-meta\">\n                                                <h4 className=\"author-name\">\n                                                    {post.authors.map((author, i) => (\n                                                        <Link key={i} to={resolveUrl(basePath, `/`, author.slug, author.url)}>{author.name}</Link>\n                                                    ))}\n                                                </h4>\n                                                <div className=\"byline-meta-content\">\n                                                    <time className=\"byline-meta-date\" dateTime={post.published_at}>\n                                                        {post.published_at_pretty}&nbsp;\n                                                    </time>\n                                                    <span className=\"byline-reading-time\"><span className=\"bull\">&bull;</span> {readingTime}</span>\n                                                </div>\n                                            </section>\n                                        </section>\n                                    </div>\n                                </header>\n\n                                <figure className=\"post-full-image\">\n                                    <ImgSharp fluidClass=\"kg-card kg-code-card\" fluidImg={fluidFeatureImg} srcImg={featImg} title={post.title}/>\n                                </figure>\n\n                                <section className=\"post-full-content\">\n                                    <TableOfContents toc={toc} url={resolveUrl(basePath, pageContext.collectionPaths[post.id], post.slug, post.url)}/>\n\n                                    <div className=\"post-content load-external-scripts\"\n                                        dangerouslySetInnerHTML={{ __html: transformedHtml || post.html }}/>\n                                </section>\n\n                                <Subscribe />\n\n                                <Comments id={post.id}/>\n\n                            </article>\n                        </div>\n                    </Layout>\n                )}/>\n            )}/>\n        </React.Fragment>\n    )\n}\n\nPost.propTypes = {\n    data: PropTypes.shape({\n        ghostPost: PropTypes.shape({\n            codeinjection_styles: PropTypes.string,\n            url: PropTypes.string.isRequired,\n            slug: PropTypes.string.isRequired,\n            id: PropTypes.string.isRequired,\n            title: PropTypes.string.isRequired,\n            html: PropTypes.string.isRequired,\n            custom_excerpt: PropTypes.string,\n            feature_image: PropTypes.string,\n            featured: PropTypes.bool,\n            tags: PropTypes.arrayOf(\n                PropTypes.object.isRequired,\n            ),\n            authors: PropTypes.arrayOf(\n                PropTypes.object.isRequired,\n            ).isRequired,\n            primary_tag: PropTypes.shape({\n                name: PropTypes.string,\n                slug: PropTypes.string.isRequired,\n                url: PropTypes.string.isRequired,\n            }),\n            published_at: PropTypes.string.isRequired,\n            published_at_pretty: PropTypes.string.isRequired,\n            featureImageSharp: PropTypes.object,\n            childHtmlRehype: PropTypes.shape({\n                html: PropTypes.string,\n                tableOfContents: PropTypes.arrayOf(\n                    PropTypes.object,\n                ),\n            }),\n        }).isRequired,\n        prev: PropTypes.object,\n        next: PropTypes.object,\n        allGhostPost: PropTypes.object.isRequired,\n    }).isRequired,\n    location: PropTypes.object.isRequired,\n    pageContext: PropTypes.object,\n}\n\nexport default Post\n\nexport const postQuery = graphql`\n    query($slug: String!, $prev: String!, $next: String!, $tag: String!, $limit: Int!, $skip: Int!) {\n        ghostPost: ghostPost(slug: { eq: $slug }) {\n            ...GhostPostFields\n        }\n        prev: ghostPost(slug: { eq: $prev }) {\n            ...GhostPostFields\n        }\n        next: ghostPost(slug: { eq: $next }) {\n            ...GhostPostFields\n        }\n        allGhostPost(\n            filter: {slug: { ne: $slug },tags: {elemMatch: {slug: {eq: $tag}}}},\n            limit: $limit,\n            skip: $skip,\n            sort: { fields: [featured, published_at], order: [DESC, DESC] }\n        ) {\n            edges {\n                node {\n                ...GhostPostFields\n                }\n            }\n        }\n    }\n`\n"],"sourceRoot":""}